---
title: "Checkpoint 4"
author: "Will Madairy, Sofia Pozsonyiova, Quinn Rafferty, Federico Chung"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
header-includes:
  - \usepackage{tabularx}
output:
  pdf_document: default
  html_document: default
---

```{r, warning=FALSE, include=FALSE}
library(dplyr)
library(usmap)
library(maps)
library(ggplot2)
library(tidyverse)
library(ggmap)
library(viridis)
library(rgdal)
library(gridExtra)
library(plotly)
require(janitor)
require(reshape2)
require(tidyr)
require(rstan)
require(rstanarm)
require(bayesplot)
```


```{r}
################################## To do before Alicia with your fave model ##########################################
# mcmc_trace()
# mcmc_dens_overlay()
# pp_check()

### For predicting one case 
          # new_308 <- data.frame(Days = 9, Subject =308)
          # 
          # set.seed(454)
          # pred_308 <- posterior_predict(
          #   model_4, 
          #   newdata = new_308)
          # 
          # pred_308 <- data.frame(y_new = pred_308[-1])
          # 
          # ggplot(pred_308, aes(x=y_new))+geom_density()
          # 
          # summary(pred_308)


## For correlation check (type like model 2 from activity 19)
          # Store the chains
          # model_1_df <- as.array(model_1) %>% 
          #   melt %>% 
          #   pivot_wider(names_from = parameters, values_from = value)
          # 
          # # Wrangle the chains
          # # Note the need for `...` around the sigma_sq_b
          # model_1_df <- model_1_df %>% 
          #   mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[Region:(Intercept),(Intercept)]`) %>% 
          #   mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))
          # 
          # ggplot(model_1_df, aes(x = correlation)) + 
          #   geom_density(alpha = 0.5)
```

```{r, include=FALSE}
prediction_summary_data <- function(y, yrep, prob_inner = 0.5, prob_outer = 0.95){
  # Calculate summary statistics of simulated 
  # posterior predictive models for each case
  l_outer <- function(x){quantile(x, (1-prob_outer) / 2)}
  l_inner <- function(x){quantile(x, (1-prob_inner) / 2)}
  u_inner <- function(x){quantile(x, 1 - (1-prob_inner) / 2)}
  u_outer <- function(x){quantile(x, 1 - (1-prob_outer) / 2)}
  df <- data.frame(yrep) %>% 
    summarize_all(list(mean, sd, median, mad, l_outer, l_inner, u_inner, u_outer)) %>%
    unlist() %>% 
    matrix(., length(y), 8) %>% 
    data.frame()
  names(df) <- c("post_mean", "post_sd", "post_median", "post_mad", "l_outer", "l_inner", "u_inner", "u_outer")
  data.frame(cbind(y, df))
}


prediction_summary <- function(y, yrep, prob_inner = 0.5, prob_outer = 0.95){
  # This function summarizes the predictions across all cases
  pred_data <- prediction_summary_data(y, yrep, prob_inner = prob_inner, prob_outer = prob_outer) %>% 
    mutate(error = y - post_median) %>% 
    mutate(error_scaled = error / post_mad) %>% 
    mutate(within_inner = (y >= l_inner) & (y <= u_inner)) %>% 
    mutate(within_outer = (y >= l_outer) & (y <= u_outer))
  
  
  pred_summary <- pred_data %>% 
    summarize(mae = median(abs(error)), 
      mae_scaled = median(abs(error_scaled)),
      within_inner = mean(within_inner),
      within_outer = mean(within_outer)
    )
  names(pred_summary)[3] <- paste0("within_", prob_inner*100)
  names(pred_summary)[4] <- paste0("within_", prob_outer*100)
  
  pred_summary
}
```


```{r}
Finaldata<-read_csv("time_series_final_Data.csv")
```

```{r} 
Finaldata <- Finaldata %>% mutate(Day= as.Date(Day))
day_initial<- as.Date("2020-03-14")
day_final<- as.Date("2020-03-21")
Finaldata<- Finaldata%>%
  filter(Day>=day_initial)%>%
  filter(Day<=day_final)
```

# Quinn plots stuff
```{r}
a<- ggplot(Finaldata, aes(x = ChinaVirusInterest, fill = as.factor(State))) + 
  geom_density(alpha = 0.5)+ ggtitle("China Virus Density by State")

b<- ggplot(Finaldata, aes(x = Day, y = ChinaVirusInterest, color = factor(State))) + 
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE) + 
    facet_wrap(~ State) + 
    theme(legend.position = "right")+
    ggtitle("China Virus Interest by Day by State")

c<- ggplot(Finaldata, aes(x = ChinaVirusInterest, color = factor(StateColor))) + 
    geom_histogram() + 
    facet_wrap(~ Winner) +
    theme(legend.position = "right") + 
    scale_colour_manual( values=c("red"= "red3", "blue"= "royalblue", "purple"="darkorchid3")) +
    ggtitle("China Virus Google by State Poltical Party Winner")   

d <-  ggplot(Finaldata, aes(y=positive, x=Winner, fill=(Winner)))+
      geom_boxplot() +
      facet_wrap(~Region)+
      theme(legend.position = "none") +
      scale_fill_manual(values = c("Democrat"="blue3", "Republican"= "red3"))+
      lims(y= c(0,1000))+
      ggtitle("Positive COVID-19 Cases by State Political Party Winner & Region")

ggplotly(a)
ggplotly(b)
ggplotly(c) #Shows that Democrat states tend to have a higher interest in Googling China Virus 
ggplotly(d)

#################################### Notes!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# What affects the China Interest search, is it demographic, policitical or COVID based? 
## From Alicia:: Start by thinking, take the four models from the sleep study and just think how we can go thorugh those four models in the context of our work. 

## Chosen variables: Number of COVID-19 cases, State color, percent black, percent white, income
```

#Quinn making models
```{r, cahce=TRUE}
set.seed(454)
Finaldata<-
  Finaldata%>%
  mutate(Day=as.numeric(Day))

model_1 <- stan_glmer(
  ChinaVirusInterest ~ (1 | State), #Gives us random intercepts
  data = Finaldata, family = gaussian, chains = 4, iter = 5000*2
)
```

```{r}
head(data.frame(summary(model_1)),-2)
```

#Quinn making models
```{r, warning=FALSE, cache=TRUE}
model_2 <- stan_glmer(
  ChinaVirusInterest ~ Day + (Day | State),
  data = Finaldata, family = gaussian,
  chains = 4, iter = 100, refresh = 0
)

```

```{r}
head(data.frame(summary(model_2)),-2)
```

#Quinn makes models
```{r, warning = FALSE, cache=TRUE}
model_3 <- stan_glmer(
  ChinaVirusInterest ~ Day + StateColor + (Day | State),#Random intercepts and slopes when we put Day in
  data = Finaldata, family = gaussian,
  chains = 4, iter = 100, refresh = 0
)
```

```{r}
head(data.frame(summary(model_3)),-2)
```

#Quinn makes models
```{r, warning = FALSE, cache=TRUE}
model_4 <- stan_glmer(
  ChinaVirusInterest ~ Day + totalTestResults + (Day | State),#Random intercepts and slopes when we put Day in
  data = Finaldata, family = gaussian,
  chains = 4, iter = 100, refresh = 0
)
```

```{r}
head(data.frame(summary(model_4)),-2)
```


```{r, warning = FALSE, cache=TRUE}
model_5 <- stan_glmer(
  ChinaVirusInterest ~ Day + totalTestResults + positive + percent_white +  (Day | State),#Random intercepts and slopes when we put Day in
  data = Finaldata, family = gaussian,
  chains = 4, iter = 100, refresh = 0
)



```

#Sofia's Models: 

Variables of Interest: 
\
• per_capita_income
\
•totalTestResults
\
• StateColor
\
• percent_asian
\
•percent_black


##Model 5: 

```{r, warning = FALSE, cache=TRUE}
set.seed(454)
Finaldata<-
  Finaldata%>%
  mutate(Day=as.numeric(Day))

model_5 <- stan_glmer(
  ChinaVirusInterest ~ StateColor + (StateColor | State), #Gives us random intercepts
  data = Finaldata, family = gaussian, chains = 4, iter = 5000*2
)
```

```{r}
head(data.frame(summary(model_5)),-2)
```

Checks:

```{r}
# Trace plots
#mcmc_trace(model_5)

# Density plots
#mcmc_dens_overlay(model_5)
```

```{r}
# y = original sample, yrep = MCMC simulation
set.seed(454)
pp_check(model_5, nreps = 50)
```


```{r}
# Store the chains
model_5_df <- as.array(model_5) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_5_df <- model_5_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_b+sigma_sq_w)))


ggplot(model_5_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)

```



```{r}
#set.seed(454)
#my_data <- data.frame(StateColor = "red", State = "FL")

# Simulate a set of predictions for each case in newdata
#my_prediction <- posterior_predict(
 # model_5, 
  #newdata = my_data)

#my_prediction <- data.frame(y_new = my_prediction[,1])

#ggplot(my_prediction, aes(x = y_new)) + 
 # geom_density()

#summary(my_prediction)
```


##Model 7: 
StateColor + percent_asian + (StateColor | State)

```{r, warning = FALSE, cache=TRUE}
set.seed(454)
Finaldata<-
  Finaldata%>%
  mutate(Day=as.numeric(Day))

model_7 <- stan_glmer(
  ChinaVirusInterest ~ StateColor + percent_asian + (StateColor | State), #Gives us random intercepts
  data = Finaldata, family = gaussian, chains = 4, iter = 3000*2
)
```


```{r}
head(data.frame(summary(model_7)),-2)
```


```{r}
# y = original sample, yrep = MCMC simulation
set.seed(454)
pp_check(model_7, nreps = 50)
```


```{r}
# Store the chains
model_7_df <- as.array(model_7) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_7_df <- model_7_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_b+sigma_sq_w)))


ggplot(model_7_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)

```

```{r}
# set.seed(454)
# my_data <- data.frame(StateColor = "blue", State = "IL", percent_asian = .12)
# 
# # Simulate a set of predictions for each case in newdata
# my_prediction <- posterior_predict(
#   model_7,
#   newdata = my_data)

#my_prediction <- data.frame(y_new = my_prediction[,1])

#ggplot(my_prediction, aes(x = y_new)) +
 # geom_density()

#summary(my_prediction)
```

##Model 9: 

StateColor +percent_asian + totalTestResults + (StateColor | State)

```{r, warning = FALSE, cache=TRUE}
set.seed(454)
Finaldata<-
  Finaldata%>%
  mutate(Day=as.numeric(Day))

model_9 <- stan_glmer(
  ChinaVirusInterest ~ StateColor +percent_asian + totalTestResults + (StateColor | State), #Gives us random intercepts
  data = Finaldata, family = gaussian, chains = 4, iter = 1000*2
)
```

```{r}
head(data.frame(summary(model_9)),-2)
```



```{r}
# y = original sample, yrep = MCMC simulation
set.seed(454)
pp_check(model_9, nreps = 50)
```


```{r}
# Store the chains
model_9_df <- as.array(model_9) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_9_df <- model_9_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_b+sigma_sq_w)))


ggplot(model_9_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)

```

```{r}
#set.seed(454)
#my_data <- data.frame(StateColor = "red", State = "FL")

# Simulate a set of predictions for each case in newdata
#my_prediction <- posterior_predict(
 # model_5, 
  #newdata = my_data)

#my_prediction <- data.frame(y_new = my_prediction[,1])

#ggplot(my_prediction, aes(x = y_new)) + 
 # geom_density()

#summary(my_prediction)
```

#Fed's visualizations:
```{r}
#for visuals
install.packages("ggforce")
library(ggforce)
ggplot(Finaldata, aes(x = as.numeric(Day), y = ChinaVirusInterest, color = factor(State))) + 
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE) + 
    facet_wrap_paginate(~ State, ncol = 3, nrow = 3, page = 1) + 
    theme(legend.position = "none")
```

```{r}
ggplot(Finaldata, aes(x = as.numeric(Day), y = ChinaVirusInterest, color = factor(State))) + 
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE) + 
    facet_wrap_paginate(~ State, ncol = 3, nrow = 3, page = 2) + 
    theme(legend.position = "none")
```

```{r}
ggplot(Finaldata, aes(x = as.numeric(Day), y = ChinaVirusInterest, color = factor(State))) + 
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE) + 
    facet_wrap_paginate(~ State, ncol = 3, nrow = 3, page = 3) + 
    theme(legend.position = "none")
```

```{r}
ggplot(Finaldata, aes(x = as.numeric(Day), y = ChinaVirusInterest, color = factor(State))) + 
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE) + 
    facet_wrap_paginate(~ State, ncol = 3, nrow = 3, page = 4) + 
    theme(legend.position = "none")
```

```{r}
ggplot(Finaldata, aes(x = as.numeric(Day), y = ChinaVirusInterest, color = factor(State))) + 
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE) + 
    facet_wrap_paginate(~ State, ncol = 3, nrow = 3, page = 5) + 
    theme(legend.position = "none")
```

```{r}
ggplot(Finaldata, aes(x = as.numeric(Day), y = ChinaVirusInterest, color = factor(State))) + 
    geom_point() + 
    geom_smooth(method = "lm", se = FALSE) + 
    facet_wrap_paginate(~ State, ncol = 3, nrow = 3, page = 6) + 
    theme(legend.position = "none")
```


```{r}
Finaldata%>%
  mutate(perc_population_positive = positive/total_population)%>%
  group_by(State)%>%
  mutate(mean_corona_interest = mean(ChinaVirusInterest),
         max = max(ChinaVirusInterest),
         median = median(ChinaVirusInterest))%>%
  ggplot(aes(x = mean_corona_interest, y = perc_population_positive, color = percent_asian))+
  geom_point()+
  scale_colour_gradient2(low = "blue", mid = "lightblue", high = "red")
```

#Fed's Models:


Variables of interest:
- % white
- postive rate (out of the tested)

```{r}
set.seed(454)
glimpse(Finaldata)
model_data<-Finaldata%>%
  mutate(Date = as.numeric(Day))%>%
  mutate(positive_rate = positive/ totalTestResults)%>%
  select(State, ChinaVirusInterest, Day, percent_white,positive_rate)
model_data<- na.omit(model_data)

colSums(is.na(model_data))
```
```{r}
model_10 <- stan_glmer(
  ChinaVirusInterest ~ Day + (1 | State) + percent_white,
  data = model_data, family = gaussian, chains = 4, iter = 1000
)
```
```{r}
head(data.frame(summary(model_10)),-2)
```

```{r}
# Store the chains
model_10_df <- as.array(model_10) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_10_df <- model_10_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))

ggplot(model_10_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)
```
```{r}
set.seed(454)
#random intercept and random slope, percent white
model_11 <- stan_glmer(
  ChinaVirusInterest ~ (Day | State) + percent_white,
  data = model_data, family = gaussian, chains = 4, iter = 3000
)
```
```{r}
head(data.frame(summary(model_11)),-2)
```

```{r}
# Store the chains
model_11_df <- as.array(model_11) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_11_df <- model_11_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))

ggplot(model_10_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)
```

```{r}
set.seed(454)

model_12<- stan_glmer(
  ChinaVirusInterest ~ Day + (1 | State) + percent_white +positive_rate,
  data = model_data, family = gaussian, chains = 4, iter = 3000
)
```
```{r}
head(data.frame(summary(model_12)),-2)
```

```{r}
# Store the chains
model_12_df <- as.array(model_12) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_12_df <- model_12_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))

ggplot(model_12_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)
```


```{r}
set.seed(454)
#random intercept and random slope, percent white and positive rate = positive/ total tests
#iterations might be low need to sample up if we want to make the models better
model_13 <- stan_glmer(
  ChinaVirusInterest ~ (Day | State) + percent_white +positive_rate,
  data = model_data, family = gaussian, chains = 4, iter = 3000
)
```
```{r}
head(data.frame(summary(model_13)),-2)
```

```{r}
# Store the chains
model_13_df <- as.array(model_13) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_13_df <- model_13_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))

ggplot(model_13_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)
```
 

# Will's Models

-Variables of Interest:
*Pct Black
*Pct Positive
*Pct Negative

```{r}
mod_data<-Finaldata%>%
  mutate(Date = as.numeric(Day))%>%
  mutate(positive_rate = positive/ totalTestResults)%>%
  mutate(negative_rate = 1-positive_rate) %>% 
  select(State, ChinaVirusInterest, Day, percent_white, percent_black, positive_rate, negative_rate, KungFluInterest, Region, StateColor)
model_data<- na.omit(model_data)
```


Model 14
```{r}
set.seed(454)
#Neg Rate
model_14 <- stan_glmer(
  ChinaVirusInterest ~ (1 | State) + negative_rate,
  data = mod_data, family = gaussian, chains = 4, iter = 1000
)
```

```{r}
head(data.frame(summary(model_14)),-2)
```

Checking Model 14
```{r}
mcmc_trace(model_14)
mcmc_dens(model_14)
```
```{r}
pp_check(model_14, nreps=50)
```



```{r}
# Store the chains
model_14_df <- as.array(model_14) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_14_df <- model_14_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))

ggplot(model_14_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)
```

```{r}
set.seed(454)
my_data <- data.frame(negative_rate = .9, State = "IL", percent_black = .12)

 # Simulate a set of predictions for each case in newdata
my_prediction <- posterior_predict(
   model_14,
   newdata = my_data)

my_prediction <- data.frame(y_new = my_prediction[,1])

ggplot(my_prediction, aes(x = y_new)) +
  geom_density()

summary(my_prediction)
```


```{r}
# model_15<-stan_glmer(
#   ChinaVirusInterest ~ (Day|State) + negative_rate, 
#   data=mod_data, family=gaussian, chains =4, iter = 5000
# )
```

```{r}
# head(data.frame(summary(model_15)),-2)
```

```{r}
# # Store the chains
# model_15_df <- as.array(model_15) %>% 
#   melt %>% 
#   pivot_wider(names_from = parameters, values_from = value)
# 
# # Wrangle the chains
# # Note the need for `...` around the sigma_sq_b
# model_15_df <- model_15_df %>% 
#   mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
#   mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))
# 
# ggplot(model_15_df, aes(x = correlation)) + 
#   geom_density(alpha = 0.5)
```

```{r}
model_16<-stan_glmer(
  ChinaVirusInterest~ (1|State) + percent_black + negative_rate, 
  data = mod_data, family = gaussian, chains = 4, iter = 5000
)
```

```{r}
head(data.frame(summary(model_16)),-2)
```

```{r}
mcmc_trace(model_16)
mcmc_dens(model_16)
```

```{r}
pp_check(model_16, iter=50)
```


```{r}
# Store the chains
model_16_df <- as.array(model_16) %>% 
  melt %>% 
  pivot_wider(names_from = parameters, values_from = value)

# Wrangle the chains
# Note the need for `...` around the sigma_sq_b
model_16_df <- model_16_df %>% 
  mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
  mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))

ggplot(model_16_df, aes(x = correlation)) + 
  geom_density(alpha = 0.5)
```

```{r}
set.seed(454)
my_data <- data.frame(negative_rate = .9, State = "IL", percent_black = .12)

 # Simulate a set of predictions for each case in newdata
my_prediction <- posterior_predict(
   model_16,
   newdata = my_data)

my_prediction <- data.frame(y_new = my_prediction[,1])

ggplot(my_prediction, aes(x = y_new)) +
  geom_density()

summary(my_prediction)
```


```{r}
# # Pct black, Neg Rate: Random effects
# model_17<-stan_glmer(
#   ChinaVirusInterest~ (Day|State) + percent_black + negative_rate, 
#   data = mod_data, family = gaussian, chains = 4, iter = 2*5000
# 
# )
```

```{r}
# head(data.frame(summary(model_17)),-2)
```

```{r}
# model_17_df <- as.array(model_17) %>% 
#   melt %>% 
#   pivot_wider(names_from = parameters, values_from = value)
# 
# # Wrangle the chains
# # Note the need for `...` around the sigma_sq_b
# model_17_df <- model_17_df %>% 
#   mutate(sigma_sq_w = `sigma`, sigma_sq_b = `Sigma[State:(Intercept),(Intercept)]`) %>% 
#   mutate(correlation = (sigma_sq_b/(sigma_sq_w+sigma_sq_b)))
# 
# ggplot(model_17_df, aes(x = correlation)) + 
#   geom_density(alpha = 0.5)
```

